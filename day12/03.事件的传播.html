<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>03.事件的传播</title>
		<style type="text/css">
			#box1 {
				width: 300px;
				height: 300px;
				background: yellowgreen;
			}

			#box2 {
				width: 200px;
				height: 200px;
				background: yellow;
			}

			#box3 {
				width: 150px;
				height: 150px;
				background: skyblue;
			}
		</style>
		<script type="text/javascript">
			window.onload = function() {
				/*
				 * 分别为三个div绑定单击响应函数
				 */
				var box1 = document.getElementById("box1");
				var box2 = document.getElementById("box2");
				var box3 = document.getElementById("box3");
				
				/* 事件的传播
				 *	- 网景公司和微软公司有不同的理解
				 * 	  - 微软认为事件应该由内向外传播。既当事件触发时，应当先触发当前元素上的事件，然后再向当前元素的祖先元素上传播。既事件应该在冒泡阶段执行。
				 * 	  - 网景公司认为事件应该是由外向内传播。既当前事件触发时，应当先触发当前元素最外层的祖先元素，然后再逐步向内传播给后代。
				 * 	  - W3C综合了两个公司的方案，将事件的传播分为了三个阶段
				 * 		1. 捕获阶段
				 * 			
				 */
					
				bind(box1,"click",function(){
					alert("我是box1的响应函数")
				});
				bind(box2,"click",function(){
					alert("我是box2的响应函数")
				});
				bind(box3,"click",function(){
					alert("我是box3的响应函数")
				});
			};
			
			function bind(obj, eventStr, callback) {
				if (obj.addEventListener) {
					//大部分浏览器兼容的方式
					obj.addEventListener(eventStr, callback, false);
				} else {
					/*
					 * this由谁调用决定
					 * callback.call(obj)
					 */
					//IE8及以下
					obj.attachEvent("on" + eventStr, function() {
						//在匿名函数中调用回调函数
						callback.call(obj);
					});
				}
			}
		</script>
	</head>
	<body>
		<div id="box1">
			<div id="box2">
				<div id="box3"></div>
			</div>
		</div>
	</body>
</html>
