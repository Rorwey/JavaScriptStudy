<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>02.原型</title>
		<script type="text/javascript">
			/**
			 * 创建的每一个函数，解析器都会向函数中添加一个属性prototype。
			 * 	这个属性对应着一个对象，就是原型对象。
			 * 	当函数以构造函数形式调用时，它创建的对象中都会有一个隐含的属性，
			 * 	指向该构造函数的原型。可以通过`__proto__`来访问该属性。			 * 
			 * 
			 */
			
			function MyClass(){
				
			}
			var mc=new MyClass();
			console.log(mc.__proto__);
			var mc2=new MyClass();
			console.log(mc2.__proto__);
			/*
			 * 原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象。
			 * 	可以将对象中共有的内容，统一设置到原型对象中。
			 */
			MyClass.prototype.a=123;
			console.log(mc.a);
			/*
			 * 当访问对象的属性或方法时，会现在对象自身中寻找，如果有则使用，如果没有，会去原型对象中寻找。
			 */
			mc2.a="我是mc2的a";
			console.log(mc2.a);
			/*
			 * 创建构造函数时，可以将对象共有的属性和方法，统一添加到构造函数的原型对象中，
			 * 这样不用分别为每一个对象添加，也不会影响到全局作用域。
			 */
			
			/*
			 * 使用in检查对象中是否含有某个属性，如果对象中没有但原型中有，也会返回true
			 */
			console.log("a" in mc);
			//可以使用对象的hasOwnProperty()方法来检查对象自身是否含有改属性。
			console.log(mc.hasOwnProperty("a"));
			/*
			 * 原型对象也是对象，所以它也有原型
			 * 	当我们使用一个对象的属性或方法时，会现在自身中寻找，
			 * 如果有，则直接使用，如果，没有，
			 * 则去原型中找，如果有则使用，
			 * 如果没有，则去原型的原型中寻找。
			 * 直到找到object对象的原型，
			 * object对象的原型没有原型，如果object中依然没找到，则返回underfined
			 */
		</script>
	</head>
	<body>
	</body>
</html>
